from typing import Literal, Type, Union, Optional, overload
import torch.nn as nn
from _typeshed import Incomplete
from deeplay.blocks.conv.conv2d import Conv2dBlock as Conv2dBlock
from deeplay.external.layer import Layer as Layer
from deeplay.list import LayerList as LayerList
from deeplay.module import DeeplayModule as DeeplayModule
from typing import Any, List, Literal, Sequence, Type, overload

class ConvolutionalNeuralNetwork(DeeplayModule):
    in_channels: int | None
    hidden_channels: Sequence[int | None]
    out_channels: int
    blocks: LayerList[Conv2dBlock]
    @property
    def input(self): ...
    @property
    def hidden(self): ...
    @property
    def output(self): ...
    @property
    def layer(self) -> LayerList[Layer]: ...
    @property
    def activation(self) -> LayerList[Layer]: ...
    @property
    def normalization(self) -> LayerList[Layer]: ...
    def __init__(self, in_channels: int | None, hidden_channels: Sequence[int], out_channels: int, out_activation: Type[nn.Module] | nn.Module | None = None, pool: Type[nn.Module] | nn.Module | None = None) -> None: ...
    def forward(self, x): ...
    def pooled(self, layer: Layer = ..., before_first: bool = False): ...
    def normalized(self, normalization: Layer = ..., after_last_layer: bool = True, mode: Literal['append', 'prepend', 'insert'] = 'append', after: Incomplete | None = None): ...
    def strided(self, stride: int | tuple[int, ...], apply_to_first: bool = False): ...
    @overload
    def configure(self, in_channels: int | None = None, hidden_channels: List[int] | None = None, out_channels: int | None = None, out_activation: Type[nn.Module] | nn.Module | None = None) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], order: Sequence[str] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], index: int | slice | List[int | slice], order: Sequence[str] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    @overload
    def style(self, style: Literal["cyclegan_resnet_bottleneck"], n_blocks=7) -> Self: ...
    def style(self, style: str, **kwargs) -> Self: ...
    configure: Incomplete
