from typing import Literal, Type, Union, Optional, overload
import torch.nn as nn
from _typeshed import Incomplete
from deeplay import DeeplayModule as DeeplayModule, Layer as Layer, LayerList as LayerList
from deeplay.blocks.conv import Conv2dBlock as Conv2dBlock
from deeplay.components.cnn import ConvolutionalNeuralNetwork as ConvolutionalNeuralNetwork
from deeplay.ops import Cat as Cat
from os import remove as remove
from typing import Any, List, Literal, Sequence, Type, overload

class ConvolutionalEncoder2d(ConvolutionalNeuralNetwork):
    in_channels: int | None
    hidden_channels: Sequence[int | None]
    out_channels: int
    blocks: LayerList[Conv2dBlock]
    @property
    def channel(self) -> Sequence[int]: ...
    postprocess: Incomplete
    def __init__(self, in_channels: int | None, hidden_channels: Sequence[int], out_channels: int, out_activation: Type[nn.Module] | nn.Module | None | None = None, pool: Type[nn.Module] | nn.Module | None | None = ..., postprocess: Layer = ..., channels: Sequence[int] | None = None) -> None: ...
    def forward(self, x): ...
    def strided(self, stride: int = 2, apply_to_first_layer: bool = False, apply_to_last_layer: bool = True): ...
    @overload
    def configure(self, in_channels: int | None = None, channels: List[int] | None = None, out_channels: int | None = None, out_activation: Type[nn.Module] | nn.Module | None = None) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], order: Sequence[str] | None = None, pool: Type[nn.Module] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, postprocess: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], index: int | slice | List[int | slice], order: Sequence[str] | None = None, pool: Type[nn.Module] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, postprocess: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    configure: Incomplete
    @overload
    def style(self, style: Literal["resnet18"], ) -> Self: ...
    @overload
    def style(self, style: Literal["cyclegan_resnet_encoder"], ) -> Self: ...
    @overload
    def style(self, style: Literal["cyclegan_discriminator"], ) -> Self: ...
    @overload
    def style(self, style: Literal["dcgan_discriminator"], ) -> Self: ...
    def style(self, style: str, **kwargs) -> Self: ...

class ConvolutionalDecoder2d(ConvolutionalNeuralNetwork):
    in_channels: int | None
    channels: Sequence[int | None]
    out_channels: int
    blocks: LayerList[Conv2dBlock]
    hidden_channels: Incomplete
    preprocess: Incomplete
    def __init__(self, in_channels: int | None, hidden_channels: Sequence[int], out_channels: int, out_activation: Type[nn.Module] | nn.Module | None | None = None, preprocess: Type[nn.Module] | nn.Module = None) -> None: ...
    def forward(self, x): ...
    def upsampled(self, upsample: Layer = ..., apply_to_last_layer: bool = False, mode: str = 'append', after: Incomplete | None = None): ...
    @overload
    def configure(self, in_channels: int | None = None, hidden_channels: List[int] | None = None, out_channels: int | None = None, out_activation: Type[nn.Module] | nn.Module | None = None) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], order: Sequence[str] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, upsample: Type[nn.Module] | None = None, preprocess: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], index: int | slice | List[int | slice], order: Sequence[str] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, upsample: Type[nn.Module] | None = None, preprocess: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    configure: Incomplete
    @overload
    def style(self, style: Literal["cyclegan_resnet_decoder"], ) -> Self: ...
    @overload
    def style(self, style: Literal["dcgan_generator"], ) -> Self: ...
    def style(self, style: str, **kwargs) -> Self: ...

class ConvolutionalEncoderDecoder2d(DeeplayModule):
    in_channels: int | None
    encoder_channels: Sequence[int | None]
    decoder_channels: Sequence[int | None]
    out_channels: int | None
    @property
    def pool(self) -> LayerList[Layer]: ...
    @property
    def upsample(self) -> LayerList[Layer]: ...
    @property
    def blocks(self) -> LayerList[Layer]: ...
    @property
    def normalization(self) -> LayerList[Layer]: ...
    hidden_channels: Incomplete
    encoder: Incomplete
    bottleneck: Incomplete
    decoder: Incomplete
    def __init__(self, in_channels: int | None, encoder_channels: Sequence[int], bottleneck_channels: Sequence[int] | int | None = None, decoder_channels: Sequence[int] | None = None, out_channels: int = None, out_activation: Layer | None = None) -> None: ...
    def forward(self, x): ...

class UNet2d(ConvolutionalEncoderDecoder2d):
    in_channels: int | None
    channels: Sequence[int | None]
    out_channels: int | None
    out_activation: Type[nn.Module] | None
    skip: Type[nn.Module] | None
    def __init__(self, in_channels: int | None, encoder_channels: List[int] | None = None, bottleneck_channels: List[int] | None = None, decoder_channels: List[int] | None = None, out_channels: int = 1, out_activation: Type[nn.Module] | Layer = ..., skip: DeeplayModule = ..., channels: Sequence[int] | None = None) -> None: ...
    def forward(self, x): ...
    @overload
    def configure(self, skip: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
