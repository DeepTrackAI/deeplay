from typing import Literal, Type, Union, Optional, overload
import torch.nn as nn
from _typeshed import Incomplete
from deeplay import DeeplayModule as DeeplayModule, Layer as Layer, LayerList as LayerList
from deeplay.blocks.linear.linear import LinearBlock as LinearBlock
from typing import Any, List, Literal, Sequence, Type, overload

class MultiLayerPerceptron(DeeplayModule):
    in_features: int | None
    hidden_features: Sequence[int | None]
    out_features: int
    blocks: LayerList[LinearBlock]
    @property
    def input(self): ...
    @property
    def hidden(self): ...
    @property
    def output(self): ...
    @property
    def layer(self) -> LayerList[Layer]: ...
    @property
    def activation(self) -> LayerList[Layer]: ...
    @property
    def normalization(self) -> LayerList[Layer]: ...
    @property
    def dropout(self) -> LayerList[Layer]: ...
    flatten_input: Incomplete
    def __init__(self, in_features: int | None, hidden_features: Sequence[int | None], out_features: int, out_activation: Type[nn.Module] | nn.Module | None = None, flatten_input: bool = True) -> None: ...
    def forward(self, x): ...
    @overload
    def configure(self, in_features: int | None = None, hidden_features: List[int] | None = None, out_features: int | None = None, out_activation: Type[nn.Module] | nn.Module | None = None) -> None: ...
    @overload
    def configure(self, name: Literal['blocks'], index: int | slice | List[int | slice] | None = None, order: Sequence[str] | None = None, layer: Type[nn.Module] | None = None, activation: Type[nn.Module] | None = None, normalization: Type[nn.Module] | None = None, **kwargs: Any) -> None: ...
    @overload
    def style(self, style: Literal["normed_leaky"], ) -> Self: ...
    def style(self, style: str, **kwargs) -> Self: ...
    configure: Incomplete
